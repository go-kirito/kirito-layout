// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v1.0.0

package v1

import (
	context "context"
	http "github.com/go-kirito/pkg/transport/http"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)

const _ = http.SupportPackageIsVersion1

type HelloworldHTTPServer interface {
	CreateHelloworld(context.Context, *CreateHelloworldRequest) (*CreateHelloworldReply, error)
	DeleteHelloworld(context.Context, *DeleteHelloworldRequest) (*DeleteHelloworldReply, error)
	GetHelloworld(context.Context, *GetHelloworldRequest) (*GetHelloworldReply, error)
	ListHelloworld(context.Context, *ListHelloworldRequest) (*ListHelloworldReply, error)
	UpdateHelloworld(context.Context, *UpdateHelloworldRequest) (*UpdateHelloworldReply, error)
}

func RegisterHelloworldHTTPServer(s *http.Server, srv HelloworldHTTPServer) {
	s.POST("helloworld", _Helloworld_CreateHelloworld0_HTTP_Handler(srv))
	s.PUT("helloworld/{name}", _Helloworld_UpdateHelloworld0_HTTP_Handler(srv))
	s.DELETE("helloworld/{name}", _Helloworld_DeleteHelloworld0_HTTP_Handler(srv))
	s.GET("helloworld/{name}", _Helloworld_GetHelloworld0_HTTP_Handler(srv))
	s.GET("helloworld", _Helloworld_ListHelloworld0_HTTP_Handler(srv))
}

func _Helloworld_CreateHelloworld0_HTTP_Handler(srv HelloworldHTTPServer) func(ctx http.Context) {
	return func(ctx http.Context) {
		var in CreateHelloworldRequest
		if err := ctx.BindQuery(&in); err != nil {
			return ctx.Fail(err)
		}
		out, err := srv.CreateHelloworld(ctx, &in)
		if err != nil {
			return ctx.Fail(err)
		}
		return ctx.Success(out)
	}
}

func _Helloworld_UpdateHelloworld0_HTTP_Handler(srv HelloworldHTTPServer) func(ctx http.Context) {
	return func(ctx http.Context) {
		var in UpdateHelloworldRequest
		if err := ctx.BindQuery(&in); err != nil {
			return ctx.Fail(err)
		}
		if err := ctx.BindVars(&in); err != nil {
			return ctx.Fail(err)
		}
		out, err := srv.UpdateHelloworld(ctx, &in)
		if err != nil {
			return ctx.Fail(err)
		}
		return ctx.Success(out)
	}
}

func _Helloworld_DeleteHelloworld0_HTTP_Handler(srv HelloworldHTTPServer) func(ctx http.Context) {
	return func(ctx http.Context) {
		var in DeleteHelloworldRequest
		if err := ctx.BindQuery(&in); err != nil {
			return ctx.Fail(err)
		}
		if err := ctx.BindVars(&in); err != nil {
			return ctx.Fail(err)
		}
		out, err := srv.DeleteHelloworld(ctx, &in)
		if err != nil {
			return ctx.Fail(err)
		}
		return ctx.Success(out)
	}
}

func _Helloworld_GetHelloworld0_HTTP_Handler(srv HelloworldHTTPServer) func(ctx http.Context) {
	return func(ctx http.Context) {
		var in GetHelloworldRequest
		if err := ctx.BindQuery(&in); err != nil {
			return ctx.Fail(err)
		}
		if err := ctx.BindVars(&in); err != nil {
			return ctx.Fail(err)
		}
		out, err := srv.GetHelloworld(ctx, &in)
		if err != nil {
			return ctx.Fail(err)
		}
		return ctx.Success(out)
	}
}

func _Helloworld_ListHelloworld0_HTTP_Handler(srv HelloworldHTTPServer) func(ctx http.Context) {
	return func(ctx http.Context) {
		var in ListHelloworldRequest
		if err := ctx.BindQuery(&in); err != nil {
			return ctx.Fail(err)
		}
		out, err := srv.ListHelloworld(ctx, &in)
		if err != nil {
			return ctx.Fail(err)
		}
		return ctx.Success(out)
	}
}

type HelloworldHTTPClient interface {
	CreateHelloworld(ctx context.Context, req *CreateHelloworldRequest, opts ...http.CallOption) (rsp *CreateHelloworldReply, err error)
	DeleteHelloworld(ctx context.Context, req *DeleteHelloworldRequest, opts ...http.CallOption) (rsp *DeleteHelloworldReply, err error)
	GetHelloworld(ctx context.Context, req *GetHelloworldRequest, opts ...http.CallOption) (rsp *GetHelloworldReply, err error)
	ListHelloworld(ctx context.Context, req *ListHelloworldRequest, opts ...http.CallOption) (rsp *ListHelloworldReply, err error)
	UpdateHelloworld(ctx context.Context, req *UpdateHelloworldRequest, opts ...http.CallOption) (rsp *UpdateHelloworldReply, err error)
}

type HelloworldHTTPClientImpl struct {
	cc *http.Client
}

func NewHelloworldHTTPClient(client *http.Client) HelloworldHTTPClient {
	return &HelloworldHTTPClientImpl{client}
}

func (c *HelloworldHTTPClientImpl) CreateHelloworld(ctx context.Context, in *CreateHelloworldRequest, opts ...http.CallOption) (*CreateHelloworldReply, error) {
	var out CreateHelloworldReply
	path := "helloworld"
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)

	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *HelloworldHTTPClientImpl) DeleteHelloworld(ctx context.Context, in *DeleteHelloworldRequest, opts ...http.CallOption) (*DeleteHelloworldReply, error) {
	var out DeleteHelloworldReply
	path := "helloworld/{name}"
	err := c.cc.Invoke(ctx, "DELETE", path, in, &out, opts...)

	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *HelloworldHTTPClientImpl) GetHelloworld(ctx context.Context, in *GetHelloworldRequest, opts ...http.CallOption) (*GetHelloworldReply, error) {
	var out GetHelloworldReply
	path := "helloworld/{name}"
	err := c.cc.Invoke(ctx, "GET", path, in, &out, opts...)

	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *HelloworldHTTPClientImpl) ListHelloworld(ctx context.Context, in *ListHelloworldRequest, opts ...http.CallOption) (*ListHelloworldReply, error) {
	var out ListHelloworldReply
	path := "helloworld"
	err := c.cc.Invoke(ctx, "GET", path, in, &out, opts...)

	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *HelloworldHTTPClientImpl) UpdateHelloworld(ctx context.Context, in *UpdateHelloworldRequest, opts ...http.CallOption) (*UpdateHelloworldReply, error) {
	var out UpdateHelloworldReply
	path := "helloworld/{name}"
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)

	if err != nil {
		return nil, err
	}
	return &out, err
}
